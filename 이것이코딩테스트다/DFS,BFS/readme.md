# 자료구조
데이터를 표현하고 관리하고 처리하기 위한 구조

## 스택
선입후출 구조 또는 후입선출 구조로, 넣은 순차와 반대로 뺄 수 있는 자료구조 

## 큐
선입선출 구조로, 먼저 들어온 자료가 먼저 나가는 공정한 자료구조

## 재귀함수
자기 자신을 다시 호출하는 함수
### 재귀 함수의 종료 조건
재귀 함수를 사용할 때는 재귀 함수가 언제 끝날지, 종료 조건을 꼭 명시해야한다. 아니면 함수가 무한 호출될 수 있다.

## 탐색
많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
-> 탐색 알고리즘 중 DFS와 BFS를 알아본다.

# 그래프의 구조
노드(정점)와 간선으로 표현된다. 그래프 탐색은 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다
## 인접 행렬
2차원 배열로 그래프의 연결 관계를 표현하는 방식으로 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식이다. graph[i][j]로 연결된 간선에 대한 정보를 얻을 수 있다.
만약 간선의 정보가 0이면 노드 자신을 의미하고, INF면 연결되어 있지 않음을 의미한다. 메모리 공간을 많이 낭비하지만, 시간이 짧게 걸린다.
## 인접 리스트
리스트로 그래프의 연결 관계를 표현하는 방식으로 연결된 데이터를 하나씩 확인해야한다. 메모리 공간을 많이 낭비하지 않지만, 탐색하는데 시간이 많이 걸린다.

# DFS
깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
## 탐색 동작 과정
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다.
3. (2)번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.

## DFS 코드
~~~python
def dfs(graph, v, visited):
    visited[v] = True
    print(v, end=' ')
    for i in graph[v]:
        if not visited[i]:
        dfs(graph, i, visited)

graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

visited = [False] * 9
dfs(graph, 1, visited)
~~~

# BFS
너브 우선 탐색이라고도 불리며, 가까운 노드부터 탐색하는 알고리즘이다.
## 탐색 동작 과정
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다.
3. (2)번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.
## 특징
일반적인 경우 실제 수행 시간은 DFS보다 좋은 편이다.
~~~python
from collections import deque

def bfs(graph, start, visited):
    queue = deque([start])
    visited[start] = True
    while queue:
    v = queue.popleft()
    print(v, end=' ')
    for i in graph[v]:
        if not visited[i]:
        queue.append(i)
        visited[i] = True
        
graph = [
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7]
]

visited = [False]*9
bfs(graph, 1, visited)
~~~

